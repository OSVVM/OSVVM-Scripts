#  File Name:         OsvvmScriptsFileCreate.tcl
#  Purpose:           Scripts for running simulations
#  Revision:          OSVVM MODELS STANDARD VERSION
#
#  Maintainer:        Jim Lewis      email:  jim@synthworks.com
#  Contributor(s):
#     Jim Lewis           email:  jim@synthworks.com
#     Markus Ferringer    Patterns for error handling and callbacks, ...
#
#  Description
#    Tcl procedures to Autogenerate Files
#
#  Developed by:
#        SynthWorks Design Inc.
#        VHDL Training Classes
#        OSVVM Methodology and Model Library
#        11898 SW 128th Ave.  Tigard, Or  97223
#        http://www.SynthWorks.com
#
#  Revision History:
#    Date      Version    Description
#     1/2025   2025.01    Initial
#
#
#  This file is part of OSVVM.
#
#  Copyright (c) 2025 by SynthWorks Design Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

package require fileutil

namespace eval ::osvvm {

# -------------------------------------------------
# FindOsvvmSettingsDirectory
#
proc FindOsvvmSettingsDirectory {{OsvvmSubdirectory "osvvm"}} {
  # When StartUpShared.tcl calls this to determine the value of ::osvvm::OsvvmUserSettingsDirectory, 
  # OsvvmSettingsLocal.tcl has not been run yet, as a result,
  #   * OsvvmSettingsSubdirectory will have its default value of "" and
  #   * SettingsAreRelativeToSimulationDirectory will have its default value of false.
  # For OsvvmSettingsSubdirectory, this is ok as it is only needed to differentiate the VHDL code and not the settings.
  # SettingsAreRelativeToSimulationDirectory this is not ok and it usage has been deprecated. 
  #    This was used to differentiate VHDL sources for different simulators - use OsvvmSettingsSubdirectory instead
  #
  
  set SettingsRootDirectory ${::osvvm::OsvvmHomeDirectory}
  if {$::osvvm::SettingsAreRelativeToSimulationDirectory} {
    puts "WARNING:   SettingsAreRelativeToSimulationDirectory is deprecated.  Usage will generate an error in the future"
    set SettingsRootDirectory [file normalize ${::osvvm::CurrentSimulationDirectory}]
  }

  if {[info exists ::env(OSVVM_SETTINGS_DIR)]} {
    # Note that OSVVM_SETTINGS_DIR may be either an absolute or relative path
    # For relative paths, use OsvvmHomeDirectory (location of OsvvmLibraries) as the base
    set SettingsDirectory $::env(OSVVM_SETTINGS_DIR) 
  } elseif {[file isdirectory ${SettingsRootDirectory}/../OsvvmSettings]} {
    set SettingsDirectory ../OsvvmSettings 
  } else {
    puts "Note: Putting setting in directory OsvvmLibraries/${OsvvmSubdirectory}"
    set SettingsDirectory ${OsvvmSubdirectory} 
  }
  
  set SettingsDirectoryFullPath [file normalize [file join ${SettingsRootDirectory} ${SettingsDirectory} ${::osvvm::OsvvmSettingsSubdirectory}]]
    
  CreateDirectory $SettingsDirectoryFullPath
#  set RelativeSettingsDirectory [::fileutil::relative [pwd] $SettingsDirectoryFullPath]
#  return $RelativeSettingsDirectory
  # Needs to be a normalized path
  return $SettingsDirectoryFullPath
}


# -------------------------------------------------
#  CreateOsvvmScriptSettingsPkg
#
proc CreateOsvvmScriptSettingsPkg {SettingsDirectory} {
  set OsvvmScriptSettingsPkgFile  [file join ${SettingsDirectory} "OsvvmScriptSettingsPkg_generated.vhd"] 
  set NewFileName                 [file join ${SettingsDirectory} "OsvvmScriptSettingsPkg_new.vhd"]   
  
  set WriteCode [catch {set FileHandle  [open $NewFileName w]} WriteErrMsg]
  if {$WriteCode} { 
    puts "Not able to open OsvvmScriptSettingsPkg_generated.vhd. Using defaults instead" 
    return ""
  }
  puts $FileHandle "-- This file is autogenerated by CreateOsvvmScriptSettingsPkg" 
  puts $FileHandle "package body OsvvmScriptSettingsPkg is" 
  puts $FileHandle "  constant OSVVM_HOME_DIRECTORY         : string := \"[file normalize ${::osvvm::OsvvmHomeDirectory}]\" ;"
  if {${::osvvm::OsvvmTempOutputDirectory} eq ""} {
    puts $FileHandle "  constant OSVVM_TEMP_OUTPUT_DIRECTORY   : string := \"\" ;"
  } else {
    puts $FileHandle "  constant OSVVM_TEMP_OUTPUT_DIRECTORY   : string := \"${::osvvm::OsvvmTempOutputDirectory}/\" ;"
  }
  if {${::osvvm::OutputBaseDirectory} eq ""} {
    puts $FileHandle "  constant OSVVM_BASE_DIRECTORY  : string := \"\" ;"
  } else {
    puts $FileHandle "  constant OSVVM_BASE_DIRECTORY  : string := \"${::osvvm::OutputBaseDirectory}/\" ;"
  }
  puts $FileHandle "  constant OSVVM_BUILD_YAML_FILE        : string := \"${::osvvm::OsvvmTempYamlFile}\" ;"
  puts $FileHandle "  constant OSVVM_TRANSCRIPT_YAML_FILE   : string := \"${::osvvm::TempTranscriptYamlFile}\" ;"
  puts $FileHandle "  constant OSVVM_REVISION               : string := \"${::osvvm::OsvvmVersion}\" ;"
  puts $FileHandle "  constant OSVVM_SETTINGS_REVISION      : string := \"${::osvvm::OsvvmVersionCompatibility}\" ;"
  puts $FileHandle "end package body OsvvmScriptSettingsPkg ;" 
  close $FileHandle
  if {[FileDiff $OsvvmScriptSettingsPkgFile $NewFileName]} {
    file rename -force $NewFileName $OsvvmScriptSettingsPkgFile
  } else {
    file delete -force $NewFileName
  }
  return $OsvvmScriptSettingsPkgFile
}

# -------------------------------------------------
#  FindOsvvmScriptSettingsPkg
#
proc FindOsvvmScriptSettingsPkg { } {

  set SettingsDirectory [FindOsvvmSettingsDirectory]

  if {[FileExists $SettingsDirectory/OsvvmScriptSettingsPkg_local.vhd]} {
    return $SettingsDirectory/OsvvmScriptSettingsPkg_local.vhd

  # If SettingsDirectory is in a subdirectory for a tool and/or vendor it may be appropriate to look above to find a local "default one"
  # elsif {[FileExists $SettingsDirectory/../OsvvmScriptSettingsPkg_local.vhd]} { analyze $SettingsDirectory/../OsvvmScriptSettingsPkg_local.vhd }  

  } else {
    # Generate the file if possible
    set GeneratedPkg [CreateOsvvmScriptSettingsPkg $SettingsDirectory]
    puts "GeneratedPkg = $GeneratedPkg"
    if {[FileExists $GeneratedPkg]} {
      return   $GeneratedPkg
    } else {
      return OsvvmScriptSettingsPkg_default.vhd
    }
  }
}

# -------------------------------------------------
#  CreatePathPkg
#
proc CreatePathPkg {BaseName {SettingsDirectory ""}} {
  if {$SettingsDirectory eq ""} {set SettingsDirectory $::osvvm::OsvvmUserSettingsDirectory}
  set TestSettingsPkgFile     [file join ${SettingsDirectory} "${BaseName}PathPkg_generated.vhd"] 
  set NewFileName             [file join ${SettingsDirectory} "${BaseName}PathPkg_new.vhd"]   
  set DefaultSettingsPkgFile  [file join ${SettingsDirectory} "${BaseName}PathPkg_default.vhd"] 

  set WriteCode [catch {set FileHandle  [open $NewFileName w]} WriteErrMsg]
  if {$WriteCode} { 
    puts "Not able to open ${NewFileName}. Using defaults instead" 
    analyze ${BaseName}SettingsPkg_default.vhd
    return ""
  }
  set LocalScriptDir  "[::fileutil::relative ${::osvvm::CurrentSimulationDirectory} [file normalize ${::osvvm::CurrentWorkingDirectory}]]"
  puts $FileHandle "-- This file is autogenerated by CreatePathPkg" 
  puts $FileHandle "package ${BaseName}SettingsPkg is" 
  puts $FileHandle "  constant TEST_PATH_DIR         : string := \"${LocalScriptDir}\" ;"
  puts $FileHandle "  constant TEST_PATH_SET         : boolean := TRUE ;"
  puts $FileHandle "end package ${BaseName}SettingsPkg ;" 
  close $FileHandle
  if {[FileDiff $TestSettingsPkgFile $NewFileName]} {
    file rename -force $NewFileName $TestSettingsPkgFile
  } else {
    file delete -force $NewFileName
  }
  analyze $TestSettingsPkgFile
  return $TestSettingsPkgFile
}

# -------------------------------------------------
#  CreateTestCaseCommonPkg
#
proc CreateTestCaseCommonPkg { {PackageName "TestCaseCommonPkg"} {ValidatedResults "../ValidatedResults"} } {
#  set CurrentDir ""
  set CurrentDir [file normalize ${::osvvm::CurrentWorkingDirectory}]
  set NewFileName            [file join ${CurrentDir} "NewCreateTestCaseCommonPkg.vhd"] 
  if {${::osvvm::OutputBaseDirectory} eq ""} {
    set FileBaseName ""
  } else {
    set FileBaseName  "_${::osvvm::OutputBaseDirectory}" 
  }
  if {$::osvvm::Support2019FilePath && $::osvvm::VhdlVersion >= 2019} {
    set TestCaseCommonPkgFile  [file join ${CurrentDir} "${PackageName}${FileBaseName}.vhd"] 
  } else {
    CreateDirectory [file join ${CurrentDir} deprecated]
    set TestCaseCommonPkgFile  [file join ${CurrentDir} "deprecated" "${PackageName}${FileBaseName}_c.vhd"] 
  }
  
  if {![info exists ::osvvm::TestSuiteName]} {
    error "Call TestSuite before calling CreateTestCaseCommonPkg"
    return 
  }

  set WriteCode [catch {set FileHandle  [open $NewFileName w]} WriteErrMsg]
  if {$WriteCode} { 
    puts "ScriptError:  Not able to create ${TestCaseCommonPkgFile}" 
  } else {
    puts $FileHandle "-- This file is autogenerated by CreateTestCaseCommonPkg" 
    puts $FileHandle "library osvvm ;" 
    puts $FileHandle "context osvvm.OsvvmContext ;" 
    puts $FileHandle "package ${PackageName} is" 
    if {$::osvvm::Support2019FilePath && $::osvvm::VhdlVersion >= 2019} {
      puts $FileHandle "  constant PATH_TO_TEST_SRC            : string  := RemoveEndingSeparator(ChangeSeparator(FILE_PATH))  & \"/\";  -- only valid with VHDL-2019"
    } else {
      puts $FileHandle "  constant PATH_TO_TEST_SRC            : string := \"[file normalize [file join $::osvvm::CurrentWorkingDirectory]]/\" ;"
    }
    puts $FileHandle "  constant PATH_TO_VALIDATED_RESULTS   : string  := PATH_TO_TEST_SRC & \"${ValidatedResults}/\" ;"
    puts $FileHandle "  constant CHECK_TRANSCRIPT            : boolean := PATH_TO_TEST_SRC'length > 0 ;  -- TRUE if all went well"
    puts $FileHandle ""
    puts $FileHandle "  -- PATH_TO_RESULTS is for test case generated output other than TranscriptOpen.  If used you must create it"
    puts $FileHandle "  constant BUILD_NAME                  : string  := \"${::osvvm::BuildName}\" ;"
    puts $FileHandle "  constant TEST_SUITE_NAME             : string  := \"${::osvvm::TestSuiteName}\" ;"
    puts $FileHandle "  constant PATH_TO_RESULTS             : string := OSVVM_BASE_DIRECTORY & BUILD_NAME & \"/results/\" & TEST_SUITE_NAME & \"/\" ;"
    puts $FileHandle ""
    puts $FileHandle "  -- Deprecated.  Provided for backward compatibility"
    puts $FileHandle "  constant RESULTS_DIR             : string := PATH_TO_RESULTS ;"
    puts $FileHandle "  constant VALIDATED_RESULTS_DIR   : string := PATH_TO_VALIDATED_RESULTS ;"
    puts $FileHandle "end package ${PackageName} ;" 
    close $FileHandle
    
    if {[FileDiff $TestCaseCommonPkgFile $NewFileName]} {
      puts "Creating $TestCaseCommonPkgFile"
      file rename -force $NewFileName $TestCaseCommonPkgFile
    } else {
      puts "Files $NewFileName $TestCaseCommonPkgFile match.  No updates"
      file delete -force $NewFileName
    }
  }
  return $TestCaseCommonPkgFile
}

# -------------------------------------------------
#  CreateAndAnalyzeBuildSettingsPkg
#
proc CreateBuildSettingsPkg {BaseName {SettingsDirectory ""}} {
  if {$SettingsDirectory eq ""} {set SettingsDirectory $::osvvm::OsvvmUserSettingsDirectory}
  set TestSettingsPkgFile     [file join ${SettingsDirectory} "${BaseName}SettingsPkg_generated.vhd"] 
  set NewFileName             [file join ${SettingsDirectory} "${BaseName}SettingsPkg_new.vhd"]   
  set DefaultSettingsPkgFile  [file join ${SettingsDirectory} "${BaseName}SettingsPkg_default.vhd"] 

  set WriteCode [catch {set FileHandle  [open $NewFileName w]} WriteErrMsg]
  if {$WriteCode} { 
    puts "Not able to open ${NewFileName}. Using defaults instead" 
    analyze ${BaseName}SettingsPkg_default.vhd
    return ""
  }
  set LocalScriptDir  "[::fileutil::relative ${::osvvm::CurrentSimulationDirectory} [file normalize ${::osvvm::CurrentWorkingDirectory}]]"
  puts $FileHandle "-- This file is autogenerated by CreateBuildSettingsPkg" 
  puts $FileHandle "package ${BaseName}SettingsPkg is" 
  puts $FileHandle "  constant LOCAL_SCRIPT_DIR         : string := \"${LocalScriptDir}\" ;"
  puts $FileHandle "  constant TEST_SUITE_NAME          : string := \"${::osvvm::TestSuiteName}\" ;"
  # Should be in top level OsvvmSettings
  puts $FileHandle "  constant RESULTS_DIR              : string := \"${::osvvm::ResultsDirectory}\" ;"
  if {$::osvvm::Debug} {
    puts $FileHandle "  constant MIRROR_ENABLE            : boolean := TRUE ;"
  } else {
    puts $FileHandle "  constant MIRROR_ENABLE            : boolean := FALSE ;"
  }
  puts $FileHandle "end package ${BaseName}SettingsPkg ;" 
  close $FileHandle
  if {[FileDiff $TestSettingsPkgFile $NewFileName]} {
    file rename -force $NewFileName $TestSettingsPkgFile
  } else {
    file delete -force $NewFileName
  }
  analyze $TestSettingsPkgFile
  return $TestSettingsPkgFile
}

# -------------------------------------------------
# AutoGenerateFile 
#    Extract from FileName everything up to and including the pattern in the string
#    Write Extracted contents to NewFileName
#    Example call: set ErrorCode [catch {AutoGenerateFile $FileName $NewFileName "--!! Autogenerated:"} errmsg]
proc AutoGenerateFile {FileName NewFileName AutoGenerateMarker} {
  set ReadCode [catch {set ReadFile [open $FileName r]} ReadErrMsg]
  if {$ReadCode} { return }
  set LinesOfFile [split [read $ReadFile] \n]
  close $ReadFile
  
  set WriteCode [catch {set WriteFile  [open $NewFileName w]} WriteErrMsg]
  if {$WriteCode} { return }
  foreach OneLine $LinesOfFile {
    puts $WriteFile $OneLine
    if { [regexp ${AutoGenerateMarker} $OneLine] } {
      break
    }
  }
  close $WriteFile
}


# -------------------------------------------------
#  FileDiff
#
proc FileDiff {File1 File2} {
  set ReadFile1Code [catch {set FileHandle1 [open $File1 r]} ReadErrMsg]
  if {$ReadFile1Code} {return "true"}
  set LinesOfFile1   [split [read $FileHandle1] \n]
  close $FileHandle1
  set LengthOfFile1  [llength $$LinesOfFile1]
  
  set ReadFile2Code [catch {set FileHandle2 [open $File2 r]} ReadErrMsg]
  if {$ReadFile2Code} {return "true"}
  set LinesOfFile2   [split [read $FileHandle2] \n]
  close $FileHandle2
  set LengthOfFile2  [llength $$LinesOfFile2]

  if {$LengthOfFile1 != $LengthOfFile2} {return "true"}
  
  for {set i 0} {$i < $LengthOfFile1} {incr i} {
    if {[lindex $LinesOfFile1 $i] ne [lindex $LinesOfFile2 $i]} {return "true"}
  }
  return "false"
}



# Don't export the following due to conflicts with Tcl built-ins
# map

namespace export CreateOsvvmScriptSettingsPkg FindOsvvmSettingsDirectory CreateAndAnalyzeTestSettingsPkg
namespace export CreateTestCaseCommonPkg



# end namespace ::osvvm
}
